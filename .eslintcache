[{"/Users/richardjarram/code/catonmat/trumpsweeper/src/reportWebVitals.ts":"1","/Users/richardjarram/code/catonmat/trumpsweeper/src/App.tsx":"2","/Users/richardjarram/code/catonmat/trumpsweeper/src/index.tsx":"3","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Board.tsx":"4","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Toolbar.tsx":"5","/Users/richardjarram/code/catonmat/trumpsweeper/src/contexts.ts":"6","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Cell.tsx":"7","/Users/richardjarram/code/catonmat/trumpsweeper/src/globals.ts":"8","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/TopPanel.tsx":"9","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/ModalCompletion.tsx":"10","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Tweet.tsx":"11","/Users/richardjarram/code/catonmat/trumpsweeper/src/data/tweets.ts":"12"},{"size":425,"mtime":1607207666653,"results":"13","hashOfConfig":"14"},{"size":2446,"mtime":1612911339382,"results":"15","hashOfConfig":"14"},{"size":501,"mtime":1607208543401,"results":"16","hashOfConfig":"14"},{"size":10553,"mtime":1612827680950,"results":"17","hashOfConfig":"14"},{"size":2630,"mtime":1612903459294,"results":"18","hashOfConfig":"14"},{"size":2423,"mtime":1612905111053,"results":"19","hashOfConfig":"14"},{"size":2970,"mtime":1612821869718,"results":"20","hashOfConfig":"14"},{"size":10341,"mtime":1612905133324,"results":"21","hashOfConfig":"14"},{"size":2232,"mtime":1612912141394,"results":"22","hashOfConfig":"14"},{"size":947,"mtime":1611459412553,"results":"23","hashOfConfig":"14"},{"size":1437,"mtime":1612913645492,"results":"24","hashOfConfig":"14"},{"size":7967,"mtime":1612392254405,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"1kvdwj7",{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"28"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},"/Users/richardjarram/code/catonmat/trumpsweeper/src/reportWebVitals.ts",[],["53","54"],"/Users/richardjarram/code/catonmat/trumpsweeper/src/App.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/index.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Board.tsx",["55"],"import _ from 'lodash'\nimport { useState, useEffect } from 'react'\nimport './Board.scss'\nimport Cell from './Cell'\nimport { useGameContext } from '../contexts'\nimport TopPanel from './TopPanel'\nimport { trueTrumpTweets, falseTrumpTweets } from '../data/tweets'\nimport { \n  BoardState, \n  CellState,\n  setCellStyle,\n  GameProgress\n} \nfrom '../globals'\n\nconst Board: React.FC<BoardState> = ({boardSize, numberOfMines, mineMap} : BoardState ) => { \n  // TODO: Refactor this enum to remove redundant `state` key\n  const { difficulty, gameProgress, setGameProgress, flags, setFlags } = useGameContext()\n  const [ grid, setGrid ] = useState(buildBoard({boardSize, numberOfMines, mineMap}))\n  const [ correctlyFlaggedCells, setCorrectlyFlaggedCells ] = useState(0)\n\n  // Flag logic: accounts for when you switch difficulty; resets to zero\n  useEffect(() => {\n    setFlags(0)\n    setCorrectlyFlaggedCells(0) \n  // eslint-disable-next-line\n  }, [gameProgress, difficulty])\n\n  // redraw board after clicking on a cell\n  useEffect(() => {\n    setGrid(buildBoard({boardSize, numberOfMines, mineMap}))\n  }, [boardSize, numberOfMines, mineMap])\n\n  // redraw board after clicking on restart game modal\n  useEffect(() => {\n    if (gameProgress === GameProgress.BeginNewGame) { \n      setGrid(buildBoard({boardSize, numberOfMines, mineMap}))\n    }\n  // eslint-disable-next-line\n  }, [gameProgress])\n\n  // Completion: redraw board after victory\n  // eslint-disable-next-line\n  useEffect(() => {\n    if (correctlyFlaggedCells === numberOfMines) {\n      const updatedGrid: [any[], any[]] = _.cloneDeep(grid)\n\n      for (let row = 0; row < boardSize; row ++) {\n        for (let col = 0; col < boardSize; col ++) {\n          updatedGrid[row][col].clicked = true\n        }\n      }\n\n      setGrid(updatedGrid)\n      setGameProgress(GameProgress.Won)\n    }\n  })\n  \n  // TODO: rebuild this functionality with useContext and/or useRef()\n  // https://blog.logrocket.com/how-to-get-previous-props-state-with-react-hooks/\n  // assumption was to 'optimize' React.render by doing in-place modification of `grid` rather than re-drawing the \n  // entire board after each click. I guess I have to do the naive thing and re-render the board each time...\n  function updateBoard(j: number, i: number, rightClick?: boolean) {\n    const updatedGrid: [any[], any[]] = _.cloneDeep(grid)\n    const cell = updatedGrid[j][i]\n\n    if (rightClick) {\n      const validCell = cell.style.backgroundImage === 'url(/images/retro/unopened.svg)' ||\n      cell.style.backgroundImage === 'url(/images/retro/flag.svg)'\n      \n      if (cell.flagged === true && validCell) { \n        cell.flagged = false\n        if (flags > 0) {\n          setFlags(flags - 1)\n        }\n        if (cell.mine) {\n          setCorrectlyFlaggedCells(correctlyFlaggedCells - 1)\n        }\n      } else if (cell.flagged === false && validCell && flags < numberOfMines) { \n        cell.flagged = true\n        setFlags(flags + 1)\n        if (cell.mine) {\n          setCorrectlyFlaggedCells(correctlyFlaggedCells + 1)\n        }\n      }\n\n      // TODO: refactor this duplicate logic\n      if (correctlyFlaggedCells === numberOfMines) {\n        // set game state to won\n        // setGameProgress(GameProgress.Won)\n        // reveal entire board\n        for (let row = 0; row < boardSize; row ++) {\n          for (let col = 0; col < boardSize; col ++) {\n            updatedGrid[row][col].clicked = true\n          }\n        }\n      }\n      setGrid(updatedGrid)\n      return\n    }\n\n    // cell is a mine reveal entire board\n    if (cell.mine) { \n      for (let row = 0; row < boardSize; row ++) {\n        for (let col = 0; col < boardSize; col ++) {\n          updatedGrid[row][col].clicked = true\n        }\n      }\n\n      setGameProgress(GameProgress.Lost)\n      setGrid(updatedGrid)\n      return\n    }\n\n    // recursively open all blank cells\n    let stack: any = []\n    stack.push(cell)\n\n    while (stack.length > 0) {\n      const currentCell = stack.shift()\n\n      if (!currentCell.mine && !currentCell.clicked) {\n        currentCell.clicked = true\n        currentCell.style = setCellStyle(cell)\n      }\n\n      if (currentCell.neighbors === 0) {\n        const j = currentCell.location[0]\n        const i = currentCell.location[1]\n  \n        let neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i-1] && !updatedGrid[j-1][i-1].mine && !updatedGrid[j-1][i-1].clicked //&& updatedGrid[j-1][i-1].neighbors === 0 // top left\n        if (neighborCell) stack.push(updatedGrid[j-1][i-1])\n        neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i] && !updatedGrid[j-1][i].mine && !updatedGrid[j-1][i].clicked //&& updatedGrid[j-1][i].neighbors === 0 // top \n        if (neighborCell) stack.push(updatedGrid[j-1][i])\n        neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i+1] && !updatedGrid[j-1][i+1].mine && !updatedGrid[j-1][i+1].clicked //&& updatedGrid[j-1][i+1].neighbors === 0 // top right\n        if (neighborCell) stack.push(updatedGrid[j-1][i+1])\n        neighborCell = updatedGrid[j] && updatedGrid[j][i-1] && !updatedGrid[j][i-1].mine && !updatedGrid[j][i-1].clicked //&& updatedGrid[j][i-1].neighbors === 0 // left\n        if (neighborCell) stack.push(updatedGrid[j][i-1])\n        neighborCell = updatedGrid[j] && updatedGrid[j][i+1] && !updatedGrid[j][i+1].mine && !updatedGrid[j][i+1].clicked //&& updatedGrid[j][i+1].neighbors === 0 //right\n        if (neighborCell) stack.push(updatedGrid[j][i+1])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i-1] && !updatedGrid[j+1][i-1].mine && !updatedGrid[j+1][i-1].clicked //&& updatedGrid[j+1][i-1].neighbors === 0 //bottom right\n        if (neighborCell) stack.push(updatedGrid[j+1][i-1])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i] && !updatedGrid[j+1][i].mine && !updatedGrid[j+1][i].clicked //&& updatedGrid[j+1][i].neighbors === 0 // bottom\n        if (neighborCell) stack.push(updatedGrid[j+1][i])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i+1] && !updatedGrid[j+1][i+1].mine && !updatedGrid[j+1][i+1].clicked //&& updatedGrid[j+1][i+1].neighbors === 0 // bottom right\n        if (neighborCell) stack.push(updatedGrid[j+1][i+1])\n      }\n    }\n\n    setGameProgress(GameProgress.InProgress)\n    setGrid(updatedGrid)\n  }\n\n  return (\n    <div data-testid='board' className='board-container' id={difficulty}>\n      { \n        grid.map((column: any) => {\n          return (column.map((cellState: CellState, rowIndex: number) => { \n            // pass updateBoard() function to each child cell; on game boot up the grid is empty \n            // and so this function is nil, that is why we assign it here. \n            cellState.updateBoard = updateBoard\n            return (<Cell key={rowIndex} {...cellState}/>)\n          }))\n        })\n      }\n    </div>\n  )\n}\n\nfunction buildBoard(\n  {\n    boardSize, \n    numberOfMines,\n    mineMap\n  } : \n  { \n      boardSize: number, \n      numberOfMines: number, \n      mineMap: [number, number][]\n  }\n) \n{\n  // const userDesiresRandomMineGeneration = numberOfMines > 0\n  // const userDoesNotDesireRandomMineGeneration = mineMap[0][0] !== -1 || mineMap[0][1] !== -1 \n\n  // if (userDesiresRandomMineGeneration && userDoesNotDesireRandomMineGeneration) { \n  //   throw new Error('Please EITHER set Random Mines via `numberOfMines` or use a `mineMap` to manually build mines on the grid.')\n  // }\n  \n  // Build the empty grid\n  const grid: [any[], any[]] = [[],[]]\n  for (let j = 0; j < boardSize; j++) {\n    if (grid[j] === undefined) grid.push([])\n    for (let i = 0; i < boardSize; i++) {\n      if (grid[j][i] === undefined) grid[j].push([])\n    }\n  }\n\n  // randomly select cells from grid to turn into mines;\n  // will only run if no `mineMap` has been provided\n  const userDesiresRandomMineGeneration = (mineMap[0][0] === -1 && mineMap[0][1] === -1) || (mineMap === undefined)\n  if (userDesiresRandomMineGeneration) {\n    let mineCount: number = 0\n  \n    while (mineCount < numberOfMines) {\n      let randomRow = Math.ceil(Math.random() * (grid.length - 1))\n      let randomCol = Math.ceil(Math.random() * (grid[0].length - 1))\n      let cell = grid[randomRow][randomCol]\n  \n      if (!cell.includes('mine')) { \n        cell.push('mine')\n        mineCount += 1\n      }\n    }\n  }\n\n  // shuffle input tweet data in preparation for insertion of random tweet state into cells\n  // do deep copy to prevent draining input data set if React does multiple re-render of board drawing\n  let trueTrumpTweetsCopy = _.cloneDeep(trueTrumpTweets)\n  let falseTrumpTweetsCopy = _.cloneDeep(falseTrumpTweets)\n  _.shuffle(trueTrumpTweetsCopy)\n  _.shuffle(falseTrumpTweetsCopy)\n\n  // populate the grid with cells\n  for (let j = 0; j < boardSize; j++) {\n    for (let i = 0; i < boardSize; i++) {\n      // set mines according to user defined `MineMap`; used specifically in test case in Board.test.tsx OR set random mines\n      const mine = mineMap.find(cell => cell[0] === j && cell[1] === i) || grid[j][i][0] === 'mine'\n\n      // select random tweet: if its a mine, then it should be a false tweet\n      let tweet = mine ? falseTrumpTweetsCopy.pop() : trueTrumpTweetsCopy.pop()\n\n      const cellState: CellState = {\n        location: [j, i],\n        clicked: false,\n        mine: mine ? true : false,\n        flagged: false,\n        neighbors: 0,\n        tweet: tweet\n      }\n\n      cellState.style = setCellStyle(cellState)\n      grid[j][i] = cellState\n    }\n  }\n\n  // build neighbors\n  for (let j = 0; j < boardSize; j++) {\n    for (let i = 0; i < boardSize; i ++) {\n      let neighbors = 0\n\n      const topLeft = grid[j-1] && grid[j-1][i-1] && grid[j-1][i-1].mine // top left\n      if (topLeft) neighbors += 1\n      const top = grid[j-1] && grid[j-1][i] && grid[j-1][i].mine // top \n      if (top) neighbors += 1\n      const topRight = grid[j-1] && grid[j-1][i+1] && grid[j-1][i+1].mine // top right\n      if (topRight) neighbors += 1\n      const left = grid[j] && grid[j][i-1] && grid[j][i-1].mine // left\n      if (left) neighbors += 1\n      const right = grid[j] && grid[j][i+1] && grid[j][i+1].mine //right\n      if (right) neighbors += 1\n      const bottomLeft = grid[j+1] && grid[j+1][i-1] && grid[j+1][i-1].mine //bottom right\n      if (bottomLeft) neighbors += 1\n      const bottom = grid[j+1] && grid[j+1][i] && grid[j+1][i].mine // bottom\n      if (bottom) neighbors += 1\n      const bottomRight = grid[j+1] && grid[j+1][i+1] && grid[j+1][i+1].mine // bottom right\n      if (bottomRight) neighbors += 1\n\n      grid[j][i].neighbors = neighbors\n    }\n  }\n\n  return grid\n}\n\nexport default Board\n","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Toolbar.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/contexts.ts",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Cell.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/globals.ts",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/TopPanel.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/ModalCompletion.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Tweet.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/data/tweets.ts",[],["56","57"],{"ruleId":"58","replacedBy":"59"},{"ruleId":"60","replacedBy":"61"},{"ruleId":"62","severity":1,"message":"63","line":6,"column":8,"nodeType":"64","messageId":"65","endLine":6,"endColumn":16},{"ruleId":"58","replacedBy":"66"},{"ruleId":"60","replacedBy":"67"},"no-native-reassign",["68"],"no-negated-in-lhs",["69"],"@typescript-eslint/no-unused-vars","'TopPanel' is defined but never used.","Identifier","unusedVar",["68"],["69"],"no-global-assign","no-unsafe-negation"]