[{"/Users/richardjarram/code/catonmat/trumpsweeper/src/reportWebVitals.ts":"1","/Users/richardjarram/code/catonmat/trumpsweeper/src/App.tsx":"2","/Users/richardjarram/code/catonmat/trumpsweeper/src/index.tsx":"3","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Board.tsx":"4","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Toolbar.tsx":"5","/Users/richardjarram/code/catonmat/trumpsweeper/src/contexts.ts":"6","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Cell.tsx":"7","/Users/richardjarram/code/catonmat/trumpsweeper/src/globals.ts":"8","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/TopPanel.tsx":"9"},{"size":425,"mtime":1607207666653,"results":"10","hashOfConfig":"11"},{"size":1820,"mtime":1609107935296,"results":"12","hashOfConfig":"11"},{"size":501,"mtime":1607208543401,"results":"13","hashOfConfig":"11"},{"size":9544,"mtime":1609108049987,"results":"14","hashOfConfig":"11"},{"size":2141,"mtime":1608775836284,"results":"15","hashOfConfig":"11"},{"size":1257,"mtime":1608248453447,"results":"16","hashOfConfig":"11"},{"size":1521,"mtime":1608756385985,"results":"17","hashOfConfig":"11"},{"size":10183,"mtime":1608841655893,"results":"18","hashOfConfig":"11"},{"size":741,"mtime":1609107975127,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"18j7g8x",{"filePath":"23","messages":"24","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"22"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30","usedDeprecatedRules":"22"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"38"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"22"},"/Users/richardjarram/code/catonmat/trumpsweeper/src/reportWebVitals.ts",[],["44","45"],"/Users/richardjarram/code/catonmat/trumpsweeper/src/App.tsx",["46","47"],"import React from 'react';\nimport { GameContext, Difficulty, Theme, Opponent} from './contexts'\nimport { \n  easyBoardState, \n  regularBoardState, \n  hardBoardState, \n  testBoardState,\n  BoardState\n} from './globals'\nimport Board from './components/Board'\nimport Toolbar from './components/Toolbar'\nimport TopPanel from './components/TopPanel'\nimport './App.scss';\n\n// TODO: Add error boundaries to app: https://medium.com/@sgroff04/2-minutes-to-learn-react-16s-componentdidcatch-lifecycle-method-d1a69a1f753\nfunction App() {\n  const [difficulty, setDifficulty] = React.useState(Difficulty.Easy)\n  const [theme, setTheme] = React.useState(Theme.Retro)\n  const [opponent, setOpponent] = React.useState(Opponent.Trump)\n  const [flags, setFlags] = React.useState(0)\n\n  function drawBoard(difficulty: string) {\n    switch(difficulty) {\n      case 'easy':\n        return easyBoardState\n      case 'regular':\n        return regularBoardState\n      case 'hard':\n        return hardBoardState\n      case 'test':\n        return testBoardState\n      default:\n        throw new Error('Unable to draw board.')\n    }\n  }\n\n  function currentFlags(board: BoardState) {\n    return board.flags\n  }\n\n  function maxFlags(board: BoardState) {\n    return board.maxFlags\n  }\n\n  return (\n    <>\n      <GameContext.Provider value={{state: { difficulty, theme, opponent }, setDifficulty, setTheme, setOpponent}}>\n        <h1>APP: </h1>\n        <p>Difficulty: {difficulty}</p>\n        <p>Theme: {theme}</p>\n        <p>Opponent: {opponent}</p>\n        <p>Current Flags: {currentFlags(drawBoard(difficulty))}</p>\n        <p>Max Flags: {maxFlags(drawBoard(difficulty))}</p>\n        <TopPanel {...drawBoard(difficulty)}/>\n        <Board {...drawBoard(difficulty)}/>\n        <Toolbar />\n      </GameContext.Provider>\n    </>\n  )\n}\n\nexport default App;\n","/Users/richardjarram/code/catonmat/trumpsweeper/src/index.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Board.tsx",["48","49"],"import _ from 'lodash'\nimport { useState, useEffect } from 'react'\nimport './Board.scss'\nimport Cell from './Cell'\nimport { useSettings } from '../contexts'\nimport { \n  BoardState, \n  CellState,\n  setCellStyle,\n  GameProgress\n} \nfrom '../globals'\n\nconst Board: React.FC<BoardState> = ({gameProgress, boardSize, numberOfMines, mineMap, flags, maxFlags} : BoardState ) => { \n  // TODO: Refactor this enum to remove redundant `state` key\n  const { state: { difficulty } } = useSettings()\n  const [ grid, setGrid ] = useState(buildBoard({boardSize, numberOfMines, mineMap}))\n  const [ currentFlags, setCurrentFlags ] = useState(flags)\n  const [ correctlyFlaggedCells, setCorrectlyFlaggedCells ] = useState(0)\n  const [ currentGameProgress, setCurrentGameProgress ] = useState(gameProgress)\n\n  useEffect(() => {\n    setGrid(buildBoard({boardSize, numberOfMines, mineMap}))\n  }, [boardSize, numberOfMines, mineMap])\n\n  useEffect(() => {\n    // accounts for when you switch difficulty; resets to zero\n    setCurrentFlags(0)\n    setCorrectlyFlaggedCells(0)\n  }, [boardSize, gameProgress, numberOfMines])\n\n  useEffect(() => {\n    if (correctlyFlaggedCells === numberOfMines) {\n      const updatedGrid: [any[], any[]] = _.cloneDeep(grid)\n\n      for (let row = 0; row < boardSize; row ++) {\n        for (let col = 0; col < boardSize; col ++) {\n          updatedGrid[row][col].clicked = true\n        }\n      }\n\n      setGrid(updatedGrid)\n      setCurrentGameProgress(GameProgress.Won)\n    }\n  }, [correctlyFlaggedCells])\n  \n  // TODO: rebuild this functionality with useContext and/or useRef()\n  // https://blog.logrocket.com/how-to-get-previous-props-state-with-react-hooks/\n  // assumption was to 'optimize' React.render by doing in-place modification of `grid` rather than re-drawing the \n  // entire board after each click. I guess I have to do the naive thing and re-render the board each time...\n  function updateBoard(j: number, i: number, rightClick?: boolean) {\n    const updatedGrid: [any[], any[]] = _.cloneDeep(grid)\n    const cell = updatedGrid[j][i]\n\n    if (rightClick) {\n      const validCell = cell.style.backgroundImage === 'url(/images/retro/unopened.svg)' ||\n                        cell.style.backgroundImage === 'url(/images/retro/flag.svg)'\n\n      if (cell.flagged === true && validCell) { \n        cell.flagged = false\n        setCurrentFlags(currentFlags - 1)\n      } else if (cell.flagged === false && validCell && currentFlags < maxFlags) { \n        cell.flagged = true\n        setCurrentFlags(currentFlags + 1)\n        if (cell.mine) {\n          setCorrectlyFlaggedCells(correctlyFlaggedCells + 1)\n        }\n      }\n\n      // TODO: refactor this duplicate logic\n      if (correctlyFlaggedCells === numberOfMines) {\n        // set game state to won\n        // reveal entire board\n        for (let row = 0; row < boardSize; row ++) {\n          for (let col = 0; col < boardSize; col ++) {\n            updatedGrid[row][col].clicked = true\n          }\n        }\n      } \n      setGrid(updatedGrid)\n      return\n    }\n\n    // cell is a mine reveal entire board\n    if (cell.mine) { \n      for (let row = 0; row < boardSize; row ++) {\n        for (let col = 0; col < boardSize; col ++) {\n          updatedGrid[row][col].clicked = true\n        }\n      }\n\n      setCurrentGameProgress(GameProgress.Lost)\n      setGrid(updatedGrid)\n      return\n    }\n\n    // recursively open all blank cells\n    let stack: any = []\n    stack.push(cell)\n\n    while (stack.length > 0) {\n      const currentCell = stack.shift()\n\n      if (!currentCell.mine && !currentCell.clicked) {\n        currentCell.clicked = true\n        currentCell.style = setCellStyle(cell)\n      }\n\n      if (currentCell.neighbors === 0) {\n        const j = currentCell.location[0]\n        const i = currentCell.location[1]\n  \n        let neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i-1] && !updatedGrid[j-1][i-1].mine && !updatedGrid[j-1][i-1].clicked //&& updatedGrid[j-1][i-1].neighbors === 0 // top left\n        if (neighborCell) stack.push(updatedGrid[j-1][i-1])\n        neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i] && !updatedGrid[j-1][i].mine && !updatedGrid[j-1][i].clicked //&& updatedGrid[j-1][i].neighbors === 0 // top \n        if (neighborCell) stack.push(updatedGrid[j-1][i])\n        neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i+1] && !updatedGrid[j-1][i+1].mine && !updatedGrid[j-1][i+1].clicked //&& updatedGrid[j-1][i+1].neighbors === 0 // top right\n        if (neighborCell) stack.push(updatedGrid[j-1][i+1])\n        neighborCell = updatedGrid[j] && updatedGrid[j][i-1] && !updatedGrid[j][i-1].mine && !updatedGrid[j][i-1].clicked //&& updatedGrid[j][i-1].neighbors === 0 // left\n        if (neighborCell) stack.push(updatedGrid[j][i-1])\n        neighborCell = updatedGrid[j] && updatedGrid[j][i+1] && !updatedGrid[j][i+1].mine && !updatedGrid[j][i+1].clicked //&& updatedGrid[j][i+1].neighbors === 0 //right\n        if (neighborCell) stack.push(updatedGrid[j][i+1])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i-1] && !updatedGrid[j+1][i-1].mine && !updatedGrid[j+1][i-1].clicked //&& updatedGrid[j+1][i-1].neighbors === 0 //bottom right\n        if (neighborCell) stack.push(updatedGrid[j+1][i-1])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i] && !updatedGrid[j+1][i].mine && !updatedGrid[j+1][i].clicked //&& updatedGrid[j+1][i].neighbors === 0 // bottom\n        if (neighborCell) stack.push(updatedGrid[j+1][i])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i+1] && !updatedGrid[j+1][i+1].mine && !updatedGrid[j+1][i+1].clicked //&& updatedGrid[j+1][i+1].neighbors === 0 // bottom right\n        if (neighborCell) stack.push(updatedGrid[j+1][i+1])\n      }\n    }\n\n    setCurrentGameProgress(GameProgress.InProgress)\n    setGrid(updatedGrid)\n  }\n\n  return (\n    <div data-testid='board' className='board-container' id={difficulty}>\n      { \n        grid.map((column: any) => {\n          return (column.map((cellState: CellState, rowIndex: number) => { \n            // pass updateBoard() function to each child cell; on game boot up the grid is empty \n            // and so this function is nil, that is why we assign it here. \n            cellState.updateBoard = updateBoard\n            return (<Cell key={rowIndex} {...cellState}/>)\n          }))\n        })\n      }\n    </div>\n  )\n}\n\nfunction buildBoard(\n  {\n    boardSize, \n    numberOfMines,\n    mineMap\n  } : \n  { \n      boardSize: number, \n      numberOfMines: number, \n      mineMap: [number, number][]\n  }\n) \n{\n  // const userDesiresRandomMineGeneration = numberOfMines > 0\n  // const userDoesNotDesireRandomMineGeneration = mineMap[0][0] !== -1 || mineMap[0][1] !== -1 \n\n  // if (userDesiresRandomMineGeneration && userDoesNotDesireRandomMineGeneration) { \n  //   throw new Error('Please EITHER set Random Mines via `numberOfMines` or use a `mineMap` to manually build mines on the grid.')\n  // }\n  \n  // Build the empty grid\n  const grid: [any[], any[]] = [[],[]]\n  for (let j = 0; j < boardSize; j++) {\n    if (grid[j] === undefined) grid.push([])\n    for (let i = 0; i < boardSize; i++) {\n      if (grid[j][i] === undefined) grid[j].push([])\n    }\n  }\n\n  // randomly select cells from grid to turn into mines;\n  // will only run if no `mineMap` has been provided\n  const userDesiresRandomMineGeneration = (mineMap[0][0] === -1 && mineMap[0][1] === -1) || (mineMap === undefined)\n  if (userDesiresRandomMineGeneration) {\n    let mineCount: number = 0\n  \n    while (mineCount < numberOfMines) {\n      let randomRow = Math.ceil(Math.random() * (grid.length - 1))\n      let randomCol = Math.ceil(Math.random() * (grid[0].length - 1))\n      let cell = grid[randomRow][randomCol]\n  \n      if (!cell.includes('mine')) { \n        cell.push('mine')\n        mineCount += 1\n      }\n    }\n  }\n\n  // populate the grid with cells\n  for (let j = 0; j < boardSize; j++) {\n    for (let i = 0; i < boardSize; i++) {\n      // set mines according to user defined `MineMap`; used specifically in test case in Board.test.tsx OR set random mines\n      const mine = mineMap.find(cell => cell[0] === j && cell[1] === i) || grid[j][i][0] === 'mine'\n\n      const cellState: CellState = {\n        location: [j, i],\n        clicked: false,\n        mine: mine ? true : false,\n        flagged: false,\n        neighbors: 0\n      }\n\n      cellState.style = setCellStyle(cellState)\n      grid[j][i] = cellState\n    }\n  }\n\n  // build neighbors\n  for (let j = 0; j < boardSize; j++) {\n    for (let i = 0; i < boardSize; i ++) {\n      let neighbors = 0\n\n      const topLeft = grid[j-1] && grid[j-1][i-1] && grid[j-1][i-1].mine // top left\n      if (topLeft) neighbors += 1\n      const top = grid[j-1] && grid[j-1][i] && grid[j-1][i].mine // top \n      if (top) neighbors += 1\n      const topRight = grid[j-1] && grid[j-1][i+1] && grid[j-1][i+1].mine // top right\n      if (topRight) neighbors += 1\n      const left = grid[j] && grid[j][i-1] && grid[j][i-1].mine // left\n      if (left) neighbors += 1\n      const right = grid[j] && grid[j][i+1] && grid[j][i+1].mine //right\n      if (right) neighbors += 1\n      const bottomLeft = grid[j+1] && grid[j+1][i-1] && grid[j+1][i-1].mine //bottom right\n      if (bottomLeft) neighbors += 1\n      const bottom = grid[j+1] && grid[j+1][i] && grid[j+1][i].mine // bottom\n      if (bottom) neighbors += 1\n      const bottomRight = grid[j+1] && grid[j+1][i+1] && grid[j+1][i+1].mine // bottom right\n      if (bottomRight) neighbors += 1\n\n      grid[j][i].neighbors = neighbors\n    }\n  }\n\n  return grid\n}\n\nexport default Board\n","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Toolbar.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/contexts.ts",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Cell.tsx",["50"],"import { useState } from 'react'\nimport { CellState } from '../globals'\nimport './Cell.scss'\n\nfunction Cell({ location, clicked, mine, flagged, neighbors, updateBoard }: CellState) {\n  const style: object = setStyle(location, clicked, mine, flagged, neighbors)\n\n  function rightClick(event: React.MouseEvent<HTMLDivElement, MouseEvent>, row: number, col: number) {\n    event.preventDefault()\n    flagged = true\n    updateBoard && updateBoard(location[0], location[1], true)\n  }\n\n  return(\n    <div  className='cell' \n          data-testid={`${location[0]}-${location[1]}`} \n          style={style}\n          onContextMenu={(event) => rightClick(event, location[0], location[1])}\n          onClick={() => updateBoard ? updateBoard(location[0], location[1]) : console.error('unable to upate cell')}\n    >\n    </div>\n  )\n}\n\nfunction setStyle(location: [number, number], clicked: boolean, mine: boolean, flagged: boolean, neighbors: number) {\n  const skin = { \n    backgroundImage: `url(/images/retro/unopened.svg)`,\n    gridArea: `${location[0]}-${location[1]}`\n  }\n\n  if (flagged) {\n    skin.backgroundImage = `url(/images/retro/flag.svg)`\n  } else if (clicked && mine) {\n    skin.backgroundImage = `url(/images/retro/mine.png)`\n  } else if (clicked && !mine && !flagged && neighbors === 0) {\n    skin.backgroundImage = `url(/images/retro/opened.svg)`\n  } else if (clicked && !mine && !flagged && neighbors > 0) {\n    skin.backgroundImage = `url(/images/retro/${neighbors}.svg)`\n  }\n\n  return skin;\n}\n\nexport default Cell;\n",["51","52"],"/Users/richardjarram/code/catonmat/trumpsweeper/src/globals.ts",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/TopPanel.tsx",["53"],"import React, { useEffect } from 'react'\nimport { BoardState, GameProgress } from '../globals'\n\nexport default function TopPanel({gameProgress, boardSize, numberOfMines, mineMap, flags, maxFlags} : BoardState) {\n  const [time, setTime] = React.useState(0)\n\n  useEffect(() => {\n    console.log(gameProgress)\n    if (gameProgress === GameProgress.InProgress) {\n      const interval = setInterval(() => setTime(time + 1), 1000)\n      return () => clearInterval(interval)\n    }\n  }, [time])\n  \n  return (\n    <>\n      <div data-testid='topPanel'>\n        <Avatar/>\n        <div data-testid='timer' >Timer: {time}</div>\n      </div>\n    </>\n  )\n}\n\nfunction Avatar() {\n  return(\n    <>\n      <p>Avatar</p>\n      <img src=\"\" alt=\"\"/>\n    </>\n  )\n}\n",{"ruleId":"54","replacedBy":"55"},{"ruleId":"56","replacedBy":"57"},{"ruleId":"58","severity":1,"message":"59","line":20,"column":10,"nodeType":"60","messageId":"61","endLine":20,"endColumn":15},{"ruleId":"58","severity":1,"message":"62","line":20,"column":17,"nodeType":"60","messageId":"61","endLine":20,"endColumn":25},{"ruleId":"58","severity":1,"message":"63","line":20,"column":11,"nodeType":"60","messageId":"61","endLine":20,"endColumn":30},{"ruleId":"64","severity":1,"message":"65","line":45,"column":6,"nodeType":"66","endLine":45,"endColumn":29,"suggestions":"67"},{"ruleId":"58","severity":1,"message":"68","line":1,"column":10,"nodeType":"60","messageId":"61","endLine":1,"endColumn":18},{"ruleId":"54","replacedBy":"69"},{"ruleId":"56","replacedBy":"70"},{"ruleId":"64","severity":1,"message":"71","line":13,"column":6,"nodeType":"66","endLine":13,"endColumn":12,"suggestions":"72"},"no-native-reassign",["73"],"no-negated-in-lhs",["74"],"@typescript-eslint/no-unused-vars","'flags' is assigned a value but never used.","Identifier","unusedVar","'setFlags' is assigned a value but never used.","'currentGameProgress' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'boardSize', 'grid', and 'numberOfMines'. Either include them or remove the dependency array.","ArrayExpression",["75"],"'useState' is defined but never used.",["73"],["74"],"React Hook useEffect has a missing dependency: 'gameProgress'. Either include it or remove the dependency array.",["76"],"no-global-assign","no-unsafe-negation",{"desc":"77","fix":"78"},{"desc":"79","fix":"80"},"Update the dependencies array to be: [boardSize, correctlyFlaggedCells, grid, numberOfMines]",{"range":"81","text":"82"},"Update the dependencies array to be: [gameProgress, time]",{"range":"83","text":"84"},[1484,1507],"[boardSize, correctlyFlaggedCells, grid, numberOfMines]",[479,485],"[gameProgress, time]"]