[{"/Users/richardjarram/code/catonmat/trumpsweeper/src/reportWebVitals.ts":"1","/Users/richardjarram/code/catonmat/trumpsweeper/src/App.tsx":"2","/Users/richardjarram/code/catonmat/trumpsweeper/src/index.tsx":"3","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Board.tsx":"4","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Toolbar.tsx":"5","/Users/richardjarram/code/catonmat/trumpsweeper/src/contexts.ts":"6","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Cell.tsx":"7","/Users/richardjarram/code/catonmat/trumpsweeper/src/globals.ts":"8","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/TopPanel.tsx":"9","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/ModalCompletion.tsx":"10","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Tweet.tsx":"11","/Users/richardjarram/code/catonmat/trumpsweeper/src/data/tweets.ts":"12"},{"size":425,"mtime":1607207666653,"results":"13","hashOfConfig":"14"},{"size":2688,"mtime":1612393625120,"results":"15","hashOfConfig":"14"},{"size":501,"mtime":1607208543401,"results":"16","hashOfConfig":"14"},{"size":10441,"mtime":1612392898742,"results":"17","hashOfConfig":"14"},{"size":2606,"mtime":1611199158687,"results":"18","hashOfConfig":"14"},{"size":2445,"mtime":1612393117774,"results":"19","hashOfConfig":"14"},{"size":2970,"mtime":1612821869718,"results":"20","hashOfConfig":"14"},{"size":10343,"mtime":1612393561942,"results":"21","hashOfConfig":"14"},{"size":1773,"mtime":1612822089962,"results":"22","hashOfConfig":"14"},{"size":947,"mtime":1611459412553,"results":"23","hashOfConfig":"14"},{"size":615,"mtime":1612393923852,"results":"24","hashOfConfig":"14"},{"size":7967,"mtime":1612392254405,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"1kvdwj7",{"filePath":"29","messages":"30","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"28"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"28"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"28"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"/Users/richardjarram/code/catonmat/trumpsweeper/src/reportWebVitals.ts",[],["54","55"],"/Users/richardjarram/code/catonmat/trumpsweeper/src/App.tsx",["56"],"import React from 'react';\nimport { GameContext, Difficulty, Theme, Opponent, Flags } from './contexts'\nimport * as Global from './globals'\nimport Board from './components/Board'\nimport Toolbar from './components/Toolbar'\nimport TopPanel from './components/TopPanel'\nimport ModalCompletion from './components/ModalCompletion'\nimport Tweet from './components/Tweet'\nimport { trueTrumpTweets } from './data/tweets'\nimport './App.scss';\n\n// TODO: Add error boundaries to app: https://medium.com/@sgroff04/2-minutes-to-learn-react-16s-componentdidcatch-lifecycle-method-d1a69a1f753\nfunction App() {\n  const [difficulty, setDifficulty] = React.useState(Difficulty.Easy)\n  const [theme, setTheme] = React.useState(Theme.Retro)\n  const [opponent, setOpponent] = React.useState(Opponent.Trump)\n  const [gameProgress, setGameProgress] = React.useState(Global.GameProgress.NewGame)\n  const [flags, setFlags] = React.useState(Flags.Easy)\n  const [rightClickHeldDown, setRightClickHeldDown] = React.useState(false)\n  const [boardState] = React.useState(Global.easyBoardState)\n  const [numberOfMines, setNumberOfMines] = React.useState(Global.NumberOfMines.Easy)\n  const [currentCell, setCurrentCell] = React.useState(Global.emptyCell)\n\n  function drawBoard(difficulty: string) {\n    switch(difficulty) {\n      case 'easy':\n        return Global.easyBoardState\n      case 'regular':\n        return Global.regularBoardState\n      case 'hard':\n        return Global.hardBoardState\n      case 'test':\n        return Global.testBoardState\n      default:\n        throw new Error('Unable to draw board.')\n    }\n  }\n\n  function maxFlags(board: Global.BoardState) {\n    return board.maxFlags\n  }\n\n  return (\n    <>\n      <GameContext.Provider value={{\n          difficulty,\n          theme,\n          opponent,\n          gameProgress,\n          flags,\n          rightClickHeldDown,\n          boardState, //TO DO: remove boardState b/c it is is redundant\n          numberOfMines,\n          setDifficulty,\n          setTheme,\n          setOpponent,\n          setGameProgress,\n          setFlags,\n          setRightClickHeldDown,\n          setNumberOfMines,\n          setCurrentCell\n        }}>\n        {/* <BoardContext.Provider> */}\n        <h1>APP: </h1>\n        <p>Difficulty: {difficulty}</p>\n        <p>Progress: {gameProgress}</p>\n        <p>Theme: {theme}</p>\n        <p>Opponent: {opponent}</p>\n        <p>Current Flags: {flags}</p>\n        <p>Max Flags: {maxFlags(drawBoard(difficulty))}</p>\n        <TopPanel/>\n        <Board {...drawBoard(difficulty)}/>\n        <Toolbar />\n        <ModalCompletion/>\n        <Tweet {...currentCell}/>\n      </GameContext.Provider>\n    </>\n  )\n}\n\nexport default App;\n","/Users/richardjarram/code/catonmat/trumpsweeper/src/index.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Board.tsx",["57","58","59","60"],"import _, { sample } from 'lodash'\nimport { useState, useEffect } from 'react'\nimport './Board.scss'\nimport Cell from './Cell'\nimport { useGameContext } from '../contexts'\nimport { trueTrumpTweets, falseTrumpTweets } from '../data/tweets'\nimport { \n  BoardState, \n  CellState,\n  setCellStyle,\n  GameProgress\n} \nfrom '../globals'\n\nconst Board: React.FC<BoardState> = ({boardSize, numberOfMines, mineMap} : BoardState ) => { \n  // TODO: Refactor this enum to remove redundant `state` key\n  const { difficulty, gameProgress, setGameProgress, flags, setFlags } = useGameContext()\n  const [ grid, setGrid ] = useState(buildBoard({boardSize, numberOfMines, mineMap}))\n  const [ correctlyFlaggedCells, setCorrectlyFlaggedCells ] = useState(0)\n\n  // Flag logic: accounts for when you switch difficulty; resets to zero\n  useEffect(() => {\n    setFlags(0)\n    setCorrectlyFlaggedCells(0) \n  }, [gameProgress, difficulty])\n\n  // redraw board after clicking on a cell\n  useEffect(() => {\n    setGrid(buildBoard({boardSize, numberOfMines, mineMap}))\n  }, [boardSize, numberOfMines, mineMap])\n\n  // redraw board after clicking on restart game modal\n  useEffect(() => {\n    if (gameProgress === GameProgress.BeginNewGame) { \n      setGrid(buildBoard({boardSize, numberOfMines, mineMap}))\n    }\n  }, [gameProgress])\n\n  // Completion: redraw board after victory\n  useEffect(() => {\n    if (correctlyFlaggedCells === numberOfMines) {\n      const updatedGrid: [any[], any[]] = _.cloneDeep(grid)\n\n      for (let row = 0; row < boardSize; row ++) {\n        for (let col = 0; col < boardSize; col ++) {\n          updatedGrid[row][col].clicked = true\n        }\n      }\n\n      setGrid(updatedGrid)\n      setGameProgress(GameProgress.Won)\n    }\n  })\n  \n  // TODO: rebuild this functionality with useContext and/or useRef()\n  // https://blog.logrocket.com/how-to-get-previous-props-state-with-react-hooks/\n  // assumption was to 'optimize' React.render by doing in-place modification of `grid` rather than re-drawing the \n  // entire board after each click. I guess I have to do the naive thing and re-render the board each time...\n  function updateBoard(j: number, i: number, rightClick?: boolean) {\n    const updatedGrid: [any[], any[]] = _.cloneDeep(grid)\n    const cell = updatedGrid[j][i]\n\n    if (rightClick) {\n      const validCell = cell.style.backgroundImage === 'url(/images/retro/unopened.svg)' ||\n      cell.style.backgroundImage === 'url(/images/retro/flag.svg)'\n      \n      if (cell.flagged === true && validCell) { \n        cell.flagged = false\n        if (flags > 0) {\n          setFlags(flags - 1)\n        }\n        if (cell.mine) {\n          setCorrectlyFlaggedCells(correctlyFlaggedCells - 1)\n        }\n      } else if (cell.flagged === false && validCell && flags < numberOfMines) { \n        cell.flagged = true\n        setFlags(flags + 1)\n        if (cell.mine) {\n          setCorrectlyFlaggedCells(correctlyFlaggedCells + 1)\n        }\n      }\n\n      // TODO: refactor this duplicate logic\n      if (correctlyFlaggedCells === numberOfMines) {\n        // set game state to won\n        // setGameProgress(GameProgress.Won)\n        // reveal entire board\n        for (let row = 0; row < boardSize; row ++) {\n          for (let col = 0; col < boardSize; col ++) {\n            updatedGrid[row][col].clicked = true\n          }\n        }\n      }\n      setGrid(updatedGrid)\n      return\n    }\n\n    // cell is a mine reveal entire board\n    if (cell.mine) { \n      for (let row = 0; row < boardSize; row ++) {\n        for (let col = 0; col < boardSize; col ++) {\n          updatedGrid[row][col].clicked = true\n        }\n      }\n\n      setGameProgress(GameProgress.Lost)\n      setGrid(updatedGrid)\n      return\n    }\n\n    // recursively open all blank cells\n    let stack: any = []\n    stack.push(cell)\n\n    while (stack.length > 0) {\n      const currentCell = stack.shift()\n\n      if (!currentCell.mine && !currentCell.clicked) {\n        currentCell.clicked = true\n        currentCell.style = setCellStyle(cell)\n      }\n\n      if (currentCell.neighbors === 0) {\n        const j = currentCell.location[0]\n        const i = currentCell.location[1]\n  \n        let neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i-1] && !updatedGrid[j-1][i-1].mine && !updatedGrid[j-1][i-1].clicked //&& updatedGrid[j-1][i-1].neighbors === 0 // top left\n        if (neighborCell) stack.push(updatedGrid[j-1][i-1])\n        neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i] && !updatedGrid[j-1][i].mine && !updatedGrid[j-1][i].clicked //&& updatedGrid[j-1][i].neighbors === 0 // top \n        if (neighborCell) stack.push(updatedGrid[j-1][i])\n        neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i+1] && !updatedGrid[j-1][i+1].mine && !updatedGrid[j-1][i+1].clicked //&& updatedGrid[j-1][i+1].neighbors === 0 // top right\n        if (neighborCell) stack.push(updatedGrid[j-1][i+1])\n        neighborCell = updatedGrid[j] && updatedGrid[j][i-1] && !updatedGrid[j][i-1].mine && !updatedGrid[j][i-1].clicked //&& updatedGrid[j][i-1].neighbors === 0 // left\n        if (neighborCell) stack.push(updatedGrid[j][i-1])\n        neighborCell = updatedGrid[j] && updatedGrid[j][i+1] && !updatedGrid[j][i+1].mine && !updatedGrid[j][i+1].clicked //&& updatedGrid[j][i+1].neighbors === 0 //right\n        if (neighborCell) stack.push(updatedGrid[j][i+1])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i-1] && !updatedGrid[j+1][i-1].mine && !updatedGrid[j+1][i-1].clicked //&& updatedGrid[j+1][i-1].neighbors === 0 //bottom right\n        if (neighborCell) stack.push(updatedGrid[j+1][i-1])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i] && !updatedGrid[j+1][i].mine && !updatedGrid[j+1][i].clicked //&& updatedGrid[j+1][i].neighbors === 0 // bottom\n        if (neighborCell) stack.push(updatedGrid[j+1][i])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i+1] && !updatedGrid[j+1][i+1].mine && !updatedGrid[j+1][i+1].clicked //&& updatedGrid[j+1][i+1].neighbors === 0 // bottom right\n        if (neighborCell) stack.push(updatedGrid[j+1][i+1])\n      }\n    }\n\n    setGameProgress(GameProgress.InProgress)\n    setGrid(updatedGrid)\n  }\n\n  return (\n    <div data-testid='board' className='board-container' id={difficulty}>\n      { \n        grid.map((column: any) => {\n          return (column.map((cellState: CellState, rowIndex: number) => { \n            // pass updateBoard() function to each child cell; on game boot up the grid is empty \n            // and so this function is nil, that is why we assign it here. \n            cellState.updateBoard = updateBoard\n            return (<Cell key={rowIndex} {...cellState}/>)\n          }))\n        })\n      }\n    </div>\n  )\n}\n\nfunction buildBoard(\n  {\n    boardSize, \n    numberOfMines,\n    mineMap\n  } : \n  { \n      boardSize: number, \n      numberOfMines: number, \n      mineMap: [number, number][]\n  }\n) \n{\n  // const userDesiresRandomMineGeneration = numberOfMines > 0\n  // const userDoesNotDesireRandomMineGeneration = mineMap[0][0] !== -1 || mineMap[0][1] !== -1 \n\n  // if (userDesiresRandomMineGeneration && userDoesNotDesireRandomMineGeneration) { \n  //   throw new Error('Please EITHER set Random Mines via `numberOfMines` or use a `mineMap` to manually build mines on the grid.')\n  // }\n  \n  // Build the empty grid\n  const grid: [any[], any[]] = [[],[]]\n  for (let j = 0; j < boardSize; j++) {\n    if (grid[j] === undefined) grid.push([])\n    for (let i = 0; i < boardSize; i++) {\n      if (grid[j][i] === undefined) grid[j].push([])\n    }\n  }\n\n  // randomly select cells from grid to turn into mines;\n  // will only run if no `mineMap` has been provided\n  const userDesiresRandomMineGeneration = (mineMap[0][0] === -1 && mineMap[0][1] === -1) || (mineMap === undefined)\n  if (userDesiresRandomMineGeneration) {\n    let mineCount: number = 0\n  \n    while (mineCount < numberOfMines) {\n      let randomRow = Math.ceil(Math.random() * (grid.length - 1))\n      let randomCol = Math.ceil(Math.random() * (grid[0].length - 1))\n      let cell = grid[randomRow][randomCol]\n  \n      if (!cell.includes('mine')) { \n        cell.push('mine')\n        mineCount += 1\n      }\n    }\n  }\n\n  // shuffle input tweet data in preparation for insertion of random tweet state into cells\n  // do deep copy to prevent draining input data set if React does multiple re-render of board drawing\n  let trueTrumpTweetsCopy = _.cloneDeep(trueTrumpTweets)\n  let falseTrumpTweetsCopy = _.cloneDeep(falseTrumpTweets)\n  _.shuffle(trueTrumpTweetsCopy)\n  _.shuffle(falseTrumpTweetsCopy)\n\n  // populate the grid with cells\n  for (let j = 0; j < boardSize; j++) {\n    for (let i = 0; i < boardSize; i++) {\n      // set mines according to user defined `MineMap`; used specifically in test case in Board.test.tsx OR set random mines\n      const mine = mineMap.find(cell => cell[0] === j && cell[1] === i) || grid[j][i][0] === 'mine'\n\n      // select random tweet: if its a mine, then it should be a false tweet\n      let tweet = mine ? falseTrumpTweetsCopy.pop() : trueTrumpTweetsCopy.pop()\n\n      const cellState: CellState = {\n        location: [j, i],\n        clicked: false,\n        mine: mine ? true : false,\n        flagged: false,\n        neighbors: 0,\n        tweet: tweet\n      }\n\n      cellState.style = setCellStyle(cellState)\n      grid[j][i] = cellState\n    }\n  }\n\n  // build neighbors\n  for (let j = 0; j < boardSize; j++) {\n    for (let i = 0; i < boardSize; i ++) {\n      let neighbors = 0\n\n      const topLeft = grid[j-1] && grid[j-1][i-1] && grid[j-1][i-1].mine // top left\n      if (topLeft) neighbors += 1\n      const top = grid[j-1] && grid[j-1][i] && grid[j-1][i].mine // top \n      if (top) neighbors += 1\n      const topRight = grid[j-1] && grid[j-1][i+1] && grid[j-1][i+1].mine // top right\n      if (topRight) neighbors += 1\n      const left = grid[j] && grid[j][i-1] && grid[j][i-1].mine // left\n      if (left) neighbors += 1\n      const right = grid[j] && grid[j][i+1] && grid[j][i+1].mine //right\n      if (right) neighbors += 1\n      const bottomLeft = grid[j+1] && grid[j+1][i-1] && grid[j+1][i-1].mine //bottom right\n      if (bottomLeft) neighbors += 1\n      const bottom = grid[j+1] && grid[j+1][i] && grid[j+1][i].mine // bottom\n      if (bottom) neighbors += 1\n      const bottomRight = grid[j+1] && grid[j+1][i+1] && grid[j+1][i+1].mine // bottom right\n      if (bottomRight) neighbors += 1\n\n      grid[j][i].neighbors = neighbors\n    }\n  }\n\n  return grid\n}\n\nexport default Board\n","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Toolbar.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/contexts.ts",["61","62"],"import { createContext, useContext } from 'react'\nimport Board from './components/Board'\nimport Cell from './components/Cell'\nimport { GameProgress, BoardState, easyBoardState, NumberOfMines, CellState } from './globals'\n\n// contexts for App.tsx\nexport enum Difficulty {\n  Easy = 'easy',\n  Regular = 'regular',\n  Hard = 'hard',\n  Test = 'test'\n}\n\nexport enum Theme {\n  Retro = 'retro',\n  Dusk = 'dusk',\n}\n\nexport enum Opponent {\n  Trump = 'trump',\n  Biden = 'biden',\n}\n\nexport enum Flags {\n  Easy = 3,\n  Regular = 5,\n  Hard = 8,\n  Test = 2,\n}\n\nexport interface GameContextType {\n  difficulty: Difficulty;\n  theme: Theme;\n  opponent: Opponent;\n  gameProgress: GameProgress;\n  flags: number;\n  rightClickHeldDown?: boolean;\n  boardState?: BoardState;\n  numberOfMines?: NumberOfMines;\n  currentCell?: CellState;\n  setCurrentCell?: any;\n  setDifficulty: (Difficulty: Difficulty) => void;\n  setTheme: (Theme: Theme) => void;\n  setOpponent: (Opponent: Opponent) => void;\n  setGameProgress: (GameProgress: GameProgress) => void;\n  setFlags: (Flags: Flags) => void;\n  setRightClickHeldDown?: any;\n  setNumberOfMines: (NumberOfMines: NumberOfMines) => void;\n}\n\n//default game context\nexport const GameContext = createContext<GameContextType>({\n  difficulty: Difficulty.Easy,\n  theme: Theme.Retro,\n  opponent: Opponent.Trump,\n  gameProgress: GameProgress.NewGame,\n  boardState: easyBoardState,\n  flags: Flags.Easy,\n  rightClickHeldDown: false,\n  numberOfMines: NumberOfMines.Easy,\n  setDifficulty: () => {},\n  setTheme: () => {},\n  setOpponent: () => {},\n  setGameProgress: () => {},\n  setFlags: () => {},\n  setRightClickHeldDown: () => {},\n  setNumberOfMines: () => {}\n})\n\nexport const useGameContext = () => useContext(GameContext)\n\n// Context for Toolbar.tsx\nexport interface Options {\n  difficulty: string[];\n  theme: string[];\n  opponent: string[];\n}\n\nexport const GameOptions: Options = {\n  difficulty: [\n    Difficulty.Easy,\n    Difficulty.Regular,\n    Difficulty.Hard,\n    Difficulty.Test\n  ],\n  theme: Object.values(Theme),\n  opponent: Object.values(Opponent),\n}\n\n// mouse context used by avatar in top panel: changes image if the user clicks and holds down the mouse.\nexport interface MouseContextType {\n  rightClickHeldDown: boolean,\n  setRightClickHeldDown?: () => void\n}\n\nexport const defaultMouseContext = createContext<MouseContextType>({\n  rightClickHeldDown: false\n})\n\nexport const useMouseContext = () => useContext(defaultMouseContext)\n","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Cell.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/globals.ts",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/TopPanel.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/ModalCompletion.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Tweet.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/data/tweets.ts",[],{"ruleId":"63","replacedBy":"64"},{"ruleId":"65","replacedBy":"66"},{"ruleId":"67","severity":1,"message":"68","line":9,"column":10,"nodeType":"69","messageId":"70","endLine":9,"endColumn":25},{"ruleId":"67","severity":1,"message":"71","line":1,"column":13,"nodeType":"69","messageId":"70","endLine":1,"endColumn":19},{"ruleId":"72","severity":1,"message":"73","line":25,"column":6,"nodeType":"74","endLine":25,"endColumn":32,"suggestions":"75"},{"ruleId":"72","severity":1,"message":"76","line":37,"column":6,"nodeType":"74","endLine":37,"endColumn":20,"suggestions":"77"},{"ruleId":"72","severity":1,"message":"78","line":40,"column":3,"nodeType":"69","endLine":40,"endColumn":12,"suggestions":"79"},{"ruleId":"67","severity":1,"message":"80","line":2,"column":8,"nodeType":"69","messageId":"70","endLine":2,"endColumn":13},{"ruleId":"67","severity":1,"message":"81","line":3,"column":8,"nodeType":"69","messageId":"70","endLine":3,"endColumn":12},"no-native-reassign",["82"],"no-negated-in-lhs",["83"],"@typescript-eslint/no-unused-vars","'trueTrumpTweets' is defined but never used.","Identifier","unusedVar","'sample' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'setFlags'. Either include it or remove the dependency array.","ArrayExpression",["84"],"React Hook useEffect has missing dependencies: 'boardSize', 'mineMap', and 'numberOfMines'. Either include them or remove the dependency array. If 'setGrid' needs the current value of 'boardSize', you can also switch to useReducer instead of useState and read 'boardSize' in the reducer.",["85"],"React Hook useEffect contains a call to 'setGrid'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [correctlyFlaggedCells, numberOfMines, grid, setGameProgress, boardSize] as a second argument to the useEffect Hook.",["86"],"'Board' is defined but never used.","'Cell' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"87","fix":"88"},{"desc":"89","fix":"90"},{"desc":"91","fix":"92"},"Update the dependencies array to be: [gameProgress, difficulty, setFlags]",{"range":"93","text":"94"},"Update the dependencies array to be: [boardSize, gameProgress, mineMap, numberOfMines]",{"range":"95","text":"96"},"Add dependencies array: [correctlyFlaggedCells, numberOfMines, grid, setGameProgress, boardSize]",{"range":"97","text":"98"},[884,910],"[gameProgress, difficulty, setFlags]",[1284,1298],"[boardSize, gameProgress, mineMap, numberOfMines]",[1723,1723],", [correctlyFlaggedCells, numberOfMines, grid, setGameProgress, boardSize]"]