[{"/Users/richardjarram/code/catonmat/trumpsweeper/src/reportWebVitals.ts":"1","/Users/richardjarram/code/catonmat/trumpsweeper/src/App.tsx":"2","/Users/richardjarram/code/catonmat/trumpsweeper/src/index.tsx":"3","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Board.tsx":"4","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Toolbar.tsx":"5","/Users/richardjarram/code/catonmat/trumpsweeper/src/contexts.ts":"6","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Cell.tsx":"7","/Users/richardjarram/code/catonmat/trumpsweeper/src/globals.ts":"8","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/TopPanel.tsx":"9","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/ModalCompletion.tsx":"10"},{"size":425,"mtime":1607207666653,"results":"11","hashOfConfig":"12"},{"size":2452,"mtime":1611367204794,"results":"13","hashOfConfig":"12"},{"size":501,"mtime":1607208543401,"results":"14","hashOfConfig":"12"},{"size":9583,"mtime":1611198453771,"results":"15","hashOfConfig":"12"},{"size":2606,"mtime":1611199158687,"results":"16","hashOfConfig":"12"},{"size":2346,"mtime":1611198749572,"results":"17","hashOfConfig":"12"},{"size":1701,"mtime":1611113606450,"results":"18","hashOfConfig":"12"},{"size":9891,"mtime":1611197672297,"results":"19","hashOfConfig":"12"},{"size":1728,"mtime":1611199020559,"results":"20","hashOfConfig":"12"},{"size":629,"mtime":1611369038379,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"1kvdwj7",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"24"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"24"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"24"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/richardjarram/code/catonmat/trumpsweeper/src/reportWebVitals.ts",[],["46","47"],"/Users/richardjarram/code/catonmat/trumpsweeper/src/App.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/index.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Board.tsx",["48","49"],"import _ from 'lodash'\nimport { useState, useEffect } from 'react'\nimport './Board.scss'\nimport Cell from './Cell'\nimport { useGameContext } from '../contexts'\nimport { \n  BoardState, \n  CellState,\n  setCellStyle,\n  GameProgress\n} \nfrom '../globals'\n\nconst Board: React.FC<BoardState> = ({boardSize, numberOfMines, mineMap} : BoardState ) => { \n  // TODO: Refactor this enum to remove redundant `state` key\n  const { difficulty, gameProgress, setGameProgress, flags, setFlags } = useGameContext()\n\n  const [ grid, setGrid ] = useState(buildBoard({boardSize, numberOfMines, mineMap}))\n  const [ correctlyFlaggedCells, setCorrectlyFlaggedCells ] = useState(0)\n\n  // Flag logic: accounts for when you switch difficulty; resets to zero\n  useEffect(() => {\n    setFlags(0)\n    setCorrectlyFlaggedCells(0) \n  }, [gameProgress, difficulty])\n\n  // redraw board after clicking on a cell\n  useEffect(() => {\n    setGrid(buildBoard({boardSize, numberOfMines, mineMap}))\n  }, [boardSize, numberOfMines, mineMap])\n\n  // Completion: redraw board after victory\n  useEffect(() => {\n    if (correctlyFlaggedCells === numberOfMines) {\n      const updatedGrid: [any[], any[]] = _.cloneDeep(grid)\n\n      for (let row = 0; row < boardSize; row ++) {\n        for (let col = 0; col < boardSize; col ++) {\n          updatedGrid[row][col].clicked = true\n        }\n      }\n\n      setGrid(updatedGrid)\n      setGameProgress(GameProgress.Won)\n    }\n  })\n  \n  // TODO: rebuild this functionality with useContext and/or useRef()\n  // https://blog.logrocket.com/how-to-get-previous-props-state-with-react-hooks/\n  // assumption was to 'optimize' React.render by doing in-place modification of `grid` rather than re-drawing the \n  // entire board after each click. I guess I have to do the naive thing and re-render the board each time...\n  function updateBoard(j: number, i: number, rightClick?: boolean) {\n    const updatedGrid: [any[], any[]] = _.cloneDeep(grid)\n    const cell = updatedGrid[j][i]\n\n    if (rightClick) {\n      const validCell = cell.style.backgroundImage === 'url(/images/retro/unopened.svg)' ||\n      cell.style.backgroundImage === 'url(/images/retro/flag.svg)'\n      \n      if (cell.flagged === true && validCell) { \n        cell.flagged = false\n        if (flags > 0) {\n          setFlags(flags - 1)\n        }\n        if (cell.mine) {\n          setCorrectlyFlaggedCells(correctlyFlaggedCells - 1)\n        }\n      } else if (cell.flagged === false && validCell && flags < numberOfMines) { \n        cell.flagged = true\n        setFlags(flags + 1)\n        if (cell.mine) {\n          setCorrectlyFlaggedCells(correctlyFlaggedCells + 1)\n        }\n      }\n\n      // TODO: refactor this duplicate logic\n      if (correctlyFlaggedCells === numberOfMines) {\n        // set game state to won\n        // setGameProgress(GameProgress.Won)\n        // reveal entire board\n        for (let row = 0; row < boardSize; row ++) {\n          for (let col = 0; col < boardSize; col ++) {\n            updatedGrid[row][col].clicked = true\n          }\n        }\n      }\n      setGrid(updatedGrid)\n      return\n    }\n\n    // cell is a mine reveal entire board\n    if (cell.mine) { \n      for (let row = 0; row < boardSize; row ++) {\n        for (let col = 0; col < boardSize; col ++) {\n          updatedGrid[row][col].clicked = true\n        }\n      }\n\n      setGameProgress(GameProgress.Lost)\n      setGrid(updatedGrid)\n      return\n    }\n\n    // recursively open all blank cells\n    let stack: any = []\n    stack.push(cell)\n\n    while (stack.length > 0) {\n      const currentCell = stack.shift()\n\n      if (!currentCell.mine && !currentCell.clicked) {\n        currentCell.clicked = true\n        currentCell.style = setCellStyle(cell)\n      }\n\n      if (currentCell.neighbors === 0) {\n        const j = currentCell.location[0]\n        const i = currentCell.location[1]\n  \n        let neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i-1] && !updatedGrid[j-1][i-1].mine && !updatedGrid[j-1][i-1].clicked //&& updatedGrid[j-1][i-1].neighbors === 0 // top left\n        if (neighborCell) stack.push(updatedGrid[j-1][i-1])\n        neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i] && !updatedGrid[j-1][i].mine && !updatedGrid[j-1][i].clicked //&& updatedGrid[j-1][i].neighbors === 0 // top \n        if (neighborCell) stack.push(updatedGrid[j-1][i])\n        neighborCell = updatedGrid[j-1] && updatedGrid[j-1][i+1] && !updatedGrid[j-1][i+1].mine && !updatedGrid[j-1][i+1].clicked //&& updatedGrid[j-1][i+1].neighbors === 0 // top right\n        if (neighborCell) stack.push(updatedGrid[j-1][i+1])\n        neighborCell = updatedGrid[j] && updatedGrid[j][i-1] && !updatedGrid[j][i-1].mine && !updatedGrid[j][i-1].clicked //&& updatedGrid[j][i-1].neighbors === 0 // left\n        if (neighborCell) stack.push(updatedGrid[j][i-1])\n        neighborCell = updatedGrid[j] && updatedGrid[j][i+1] && !updatedGrid[j][i+1].mine && !updatedGrid[j][i+1].clicked //&& updatedGrid[j][i+1].neighbors === 0 //right\n        if (neighborCell) stack.push(updatedGrid[j][i+1])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i-1] && !updatedGrid[j+1][i-1].mine && !updatedGrid[j+1][i-1].clicked //&& updatedGrid[j+1][i-1].neighbors === 0 //bottom right\n        if (neighborCell) stack.push(updatedGrid[j+1][i-1])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i] && !updatedGrid[j+1][i].mine && !updatedGrid[j+1][i].clicked //&& updatedGrid[j+1][i].neighbors === 0 // bottom\n        if (neighborCell) stack.push(updatedGrid[j+1][i])\n        neighborCell = updatedGrid[j+1] && updatedGrid[j+1][i+1] && !updatedGrid[j+1][i+1].mine && !updatedGrid[j+1][i+1].clicked //&& updatedGrid[j+1][i+1].neighbors === 0 // bottom right\n        if (neighborCell) stack.push(updatedGrid[j+1][i+1])\n      }\n    }\n\n    setGameProgress(GameProgress.InProgress)\n    setGrid(updatedGrid)\n  }\n\n  return (\n    <div data-testid='board' className='board-container' id={difficulty}>\n      { \n        grid.map((column: any) => {\n          return (column.map((cellState: CellState, rowIndex: number) => { \n            // pass updateBoard() function to each child cell; on game boot up the grid is empty \n            // and so this function is nil, that is why we assign it here. \n            cellState.updateBoard = updateBoard\n            return (<Cell key={rowIndex} {...cellState}/>)\n          }))\n        })\n      }\n    </div>\n  )\n}\n\nfunction buildBoard(\n  {\n    boardSize, \n    numberOfMines,\n    mineMap\n  } : \n  { \n      boardSize: number, \n      numberOfMines: number, \n      mineMap: [number, number][]\n  }\n) \n{\n  // const userDesiresRandomMineGeneration = numberOfMines > 0\n  // const userDoesNotDesireRandomMineGeneration = mineMap[0][0] !== -1 || mineMap[0][1] !== -1 \n\n  // if (userDesiresRandomMineGeneration && userDoesNotDesireRandomMineGeneration) { \n  //   throw new Error('Please EITHER set Random Mines via `numberOfMines` or use a `mineMap` to manually build mines on the grid.')\n  // }\n  \n  // Build the empty grid\n  const grid: [any[], any[]] = [[],[]]\n  for (let j = 0; j < boardSize; j++) {\n    if (grid[j] === undefined) grid.push([])\n    for (let i = 0; i < boardSize; i++) {\n      if (grid[j][i] === undefined) grid[j].push([])\n    }\n  }\n\n  // randomly select cells from grid to turn into mines;\n  // will only run if no `mineMap` has been provided\n  const userDesiresRandomMineGeneration = (mineMap[0][0] === -1 && mineMap[0][1] === -1) || (mineMap === undefined)\n  if (userDesiresRandomMineGeneration) {\n    let mineCount: number = 0\n  \n    while (mineCount < numberOfMines) {\n      let randomRow = Math.ceil(Math.random() * (grid.length - 1))\n      let randomCol = Math.ceil(Math.random() * (grid[0].length - 1))\n      let cell = grid[randomRow][randomCol]\n  \n      if (!cell.includes('mine')) { \n        cell.push('mine')\n        mineCount += 1\n      }\n    }\n  }\n\n  // populate the grid with cells\n  for (let j = 0; j < boardSize; j++) {\n    for (let i = 0; i < boardSize; i++) {\n      // set mines according to user defined `MineMap`; used specifically in test case in Board.test.tsx OR set random mines\n      const mine = mineMap.find(cell => cell[0] === j && cell[1] === i) || grid[j][i][0] === 'mine'\n\n      const cellState: CellState = {\n        location: [j, i],\n        clicked: false,\n        mine: mine ? true : false,\n        flagged: false,\n        neighbors: 0\n      }\n\n      cellState.style = setCellStyle(cellState)\n      grid[j][i] = cellState\n    }\n  }\n\n  // build neighbors\n  for (let j = 0; j < boardSize; j++) {\n    for (let i = 0; i < boardSize; i ++) {\n      let neighbors = 0\n\n      const topLeft = grid[j-1] && grid[j-1][i-1] && grid[j-1][i-1].mine // top left\n      if (topLeft) neighbors += 1\n      const top = grid[j-1] && grid[j-1][i] && grid[j-1][i].mine // top \n      if (top) neighbors += 1\n      const topRight = grid[j-1] && grid[j-1][i+1] && grid[j-1][i+1].mine // top right\n      if (topRight) neighbors += 1\n      const left = grid[j] && grid[j][i-1] && grid[j][i-1].mine // left\n      if (left) neighbors += 1\n      const right = grid[j] && grid[j][i+1] && grid[j][i+1].mine //right\n      if (right) neighbors += 1\n      const bottomLeft = grid[j+1] && grid[j+1][i-1] && grid[j+1][i-1].mine //bottom right\n      if (bottomLeft) neighbors += 1\n      const bottom = grid[j+1] && grid[j+1][i] && grid[j+1][i].mine // bottom\n      if (bottom) neighbors += 1\n      const bottomRight = grid[j+1] && grid[j+1][i+1] && grid[j+1][i+1].mine // bottom right\n      if (bottomRight) neighbors += 1\n\n      grid[j][i].neighbors = neighbors\n    }\n  }\n\n  return grid\n}\n\nexport default Board\n","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Toolbar.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/contexts.ts",["50"],"import { createContext, useContext } from 'react'\nimport Board from './components/Board'\nimport { GameProgress, BoardState, easyBoardState, NumberOfMines } from './globals'\n\n// contexts for App.tsx\nexport enum Difficulty {\n  Easy = 'easy',\n  Regular = 'regular',\n  Hard = 'hard',\n  Test = 'test'\n}\n\nexport enum Theme {\n  Retro = 'retro',\n  Dusk = 'dusk',\n}\n\nexport enum Opponent {\n  Trump = 'trump',\n  Biden = 'biden',\n}\n\nexport enum Flags {\n  Easy = 3,\n  Regular = 5,\n  Hard = 8,\n  Test = 2,\n}\n\nexport interface GameContextType {\n  difficulty: Difficulty;\n  theme: Theme;\n  opponent: Opponent;\n  gameProgress: GameProgress;\n  flags: number;\n  rightClickHeldDown?: boolean;\n  boardState?: BoardState;\n  numberOfMines?: NumberOfMines;\n  setDifficulty: (Difficulty: Difficulty) => void;\n  setTheme: (Theme: Theme) => void;\n  setOpponent: (Opponent: Opponent) => void;\n  setGameProgress: (GameProgress: GameProgress) => void;\n  setFlags: (Flags: Flags) => void;\n  setRightClickHeldDown?: any;\n  setNumberOfMines: (NumberOfMines: NumberOfMines) => void;\n}\n\n//default game context\nexport const GameContext = createContext<GameContextType>({\n  difficulty: Difficulty.Easy,\n  theme: Theme.Retro,\n  opponent: Opponent.Trump,\n  gameProgress: GameProgress.NewGame,\n  boardState: easyBoardState,\n  flags: Flags.Easy,\n  rightClickHeldDown: false,\n  numberOfMines: NumberOfMines.Easy,\n  setDifficulty: () => {},\n  setTheme: () => {},\n  setOpponent: () => {},\n  setGameProgress: () => {},\n  setFlags: () => {},\n  setRightClickHeldDown: () => {},\n  setNumberOfMines: () => {}\n})\n\nexport const useGameContext = () => useContext(GameContext)\n\n// Context for Toolbar.tsx\nexport interface Options {\n  difficulty: string[];\n  theme: string[];\n  opponent: string[];\n}\n\nexport const GameOptions: Options = {\n  difficulty: [\n    Difficulty.Easy,\n    Difficulty.Regular,\n    Difficulty.Hard,\n    Difficulty.Test\n  ],\n  theme: Object.values(Theme),\n  opponent: Object.values(Opponent),\n}\n\n// mouse context used by avatar in top panel: changes image if the user clicks and holds down the mouse.\nexport interface MouseContextType {\n  rightClickHeldDown: boolean,\n  setRightClickHeldDown?: () => void\n}\n\nexport const defaultMouseContext = createContext<MouseContextType>({\n  rightClickHeldDown: false\n})\n\nexport const useMouseContext = () => useContext(defaultMouseContext)\n","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/Cell.tsx",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/globals.ts",[],"/Users/richardjarram/code/catonmat/trumpsweeper/src/components/TopPanel.tsx",["51"],"import React, { useEffect } from 'react'\nimport { GameProgress } from '../globals'\nimport { useGameContext } from '../contexts'\nimport './TopPanel.scss'\n\nexport default function TopPanel() {\n  const { gameProgress } = useGameContext()\n  const [time, setTime] = React.useState(0)\n\n  // countdown timer logic\n  useEffect(() => {\n    if (gameProgress === GameProgress.NewGame) setTime(0)\n    if (gameProgress === GameProgress.InProgress) {\n      const interval = setInterval(() => setTime(time + 1), 1000)\n      return () => clearInterval(interval)\n    }\n  })\n  \n  return (\n    <>\n      <div data-testid='topPanel'>\n        <FlagCounter/>\n        <Avatar gameProgress={gameProgress}/>\n        <div>Timer: <span data-testid='timer'>{time}</span></div>\n      </div>\n    </>\n  )\n}\n\nfunction FlagCounter() {\n  const { flags, numberOfMines } = useGameContext()\n\n  return(\n    <>\n      { numberOfMines && <span data-testid=\"flag-counter\">{numberOfMines - flags}</span> }\n    </>\n  )\n}\n\nfunction Avatar({gameProgress} : { gameProgress: GameProgress}) {\n  let { rightClickHeldDown } = useGameContext()\n  let avatarUrl\n\n  // avatar changes if user holds down left mouse button\n  if (rightClickHeldDown) {\n    avatarUrl = \"/images/retro/avatar/wow.png\"\n  } else {\n    // avatar changes according to game state\n    switch(gameProgress) {\n      case GameProgress.Won:\n        avatarUrl = \"/images/retro/avatar/happy.png\"\n        break\n      case GameProgress.Lost:\n        avatarUrl = \"/images/retro/avatar/sad.png\"\n        break\n      default:\n        avatarUrl = \"/images/retro/avatar/angry.png\"\n        break\n    }\n  }\n\n  return(\n    <>\n      <p>Avatar</p>\n      <img data-testid=\"avatar\" id=\"avatar\" src={avatarUrl} alt=\"\"/>\n    </>\n  )\n}\n","/Users/richardjarram/code/catonmat/trumpsweeper/src/components/ModalCompletion.tsx",[],{"ruleId":"52","replacedBy":"53"},{"ruleId":"54","replacedBy":"55"},{"ruleId":"56","severity":1,"message":"57","line":25,"column":6,"nodeType":"58","endLine":25,"endColumn":32,"suggestions":"59"},{"ruleId":"56","severity":1,"message":"60","line":33,"column":3,"nodeType":"61","endLine":33,"endColumn":12,"suggestions":"62"},{"ruleId":"63","severity":1,"message":"64","line":2,"column":8,"nodeType":"61","messageId":"65","endLine":2,"endColumn":13},{"ruleId":"56","severity":1,"message":"66","line":11,"column":3,"nodeType":"61","endLine":11,"endColumn":12,"suggestions":"67"},"no-native-reassign",["68"],"no-negated-in-lhs",["69"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'setFlags'. Either include it or remove the dependency array.","ArrayExpression",["70"],"React Hook useEffect contains a call to 'setGrid'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [correctlyFlaggedCells, numberOfMines, grid, setGameProgress, boardSize] as a second argument to the useEffect Hook.","Identifier",["71"],"@typescript-eslint/no-unused-vars","'Board' is defined but never used.","unusedVar","React Hook useEffect contains a call to 'setTime'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [gameProgress, time] as a second argument to the useEffect Hook.",["72"],"no-global-assign","no-unsafe-negation",{"desc":"73","fix":"74"},{"desc":"75","fix":"76"},{"desc":"77","fix":"78"},"Update the dependencies array to be: [gameProgress, difficulty, setFlags]",{"range":"79","text":"80"},"Add dependencies array: [correctlyFlaggedCells, numberOfMines, grid, setGameProgress, boardSize]",{"range":"81","text":"82"},"Add dependencies array: [gameProgress, time]",{"range":"83","text":"84"},[806,832],"[gameProgress, difficulty, setFlags]",[1424,1424],", [correctlyFlaggedCells, numberOfMines, grid, setGameProgress, boardSize]",[555,555],", [gameProgress, time]"]